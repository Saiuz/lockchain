contract Disposable{
    
    modifier contractOwnerOnly(){if(msg.sender != contractOwner){throw;} _ }
    address contractOwner;
    function Disposable(){contractOwner=msg.sender;}
    function Kill() contractOwnerOnly {selfdestruct(contractOwner);}
}

contract LogService{
	
	event StateChanged(bytes32 indexed source, address indexed resource, address indexed by, bytes32 message);
	event AccessDenied(bytes32 indexed source, address indexed resource, address indexed by, bytes32 message);
	event AccessGranted(bytes32 indexed source, address indexed resource, address indexed by, bytes32 message);
	
	function LogStateChanged(bytes32 source, address resource, address by, bytes32 message) returns (bool result){
		StateChanged(source, resource, by, message);
		result=true;
	}
	
    function LogAccessDenied(bytes32 source, address resource, address by) returns (bool result){
		AccessDenied(source, resource, by, "Access Denied");
		result=true;
	}

    function LogAccessGranted(bytes32 source, address resource, address by) returns (bool result){
		AccessGranted(source, resource, by, "Access Granted");
		result=true;
	}

}

contract AccessToken is Disposable{
    
    address public issuedFor;
    address public issuedTo;
    uint    public issueDate;
    uint    public beginDate;
    uint    public expiryDate;
    bool    public isExpired;
    
    function AccessToken(address subject, address resource, uint startDate, uint endDate){
        issuedFor=resource;
        issuedTo = subject;
        beginDate = startDate;
        expiryDate = endDate;
        issueDate = now;
    }
    
    function Expire() returns (bool result){
        expiryDate = now;
        isExpired=true;
        result = isExpired;
    }
    
    function Serialize() constant returns (address subject, address resource, uint startDate, uint endDate){
        subject=issuedTo;
        resource=issuedFor;
        startDate=beginDate; 
        endDate= expiryDate; 
    }
    
    function Update(uint newStartDate, uint newEndDate) returns (bool result){
        beginDate = newStartDate;
        expiryDate = newEndDate;
        issueDate = now;
        result = true;
    }
}

contract TokenIssuer{
    
    // Mapping of Subject Address To Access Token
    mapping(address=>mapping(address=>AccessToken)) public tokenStore;
    
    function TokenIssuer(){}
    
    function Grant(address subject, address resource, uint startDate, uint endDate) returns (address result){
        AccessToken token = AccessToken(tokenStore[subject][resource]);
        if(address(token)==0x0){
            token = new AccessToken(subject, resource, startDate, endDate);
            tokenStore[subject][resource] = token;
        }
        else{
            token.Update(startDate,endDate);
        }
        result=token;
    }
    
    function Revoke(address subject, address resource) returns (bool result){
        AccessToken token = AccessToken(tokenStore[subject][resource]);
        if(address(token)==0x0) return false;
        var (issuedTo, issuedFor, startDate, endDate) = token.Serialize();
        if(issuedTo == subject && issuedFor == resource){
           token.Expire();
           token.Kill();
           result = true;
           return;
        }
        result=false;
    }
    
    function GetToken(address subject, address resource) returns (address issuedTo, address issuedFor, uint startDate, uint endDate){
        AccessToken token = AccessToken(tokenStore[subject][resource]);
        if(address(token)==0x0) return;
        (issuedTo, issuedFor, startDate, endDate) = token.Serialize();
    }
    
}

contract PolicyDecisionBase{
    
    TokenIssuer public issuer;
    LogService  public logger;
    
    function PolicyDecisionBase(TokenIssuer accessIssuer, LogService logService){
        issuer=accessIssuer;
        logger=logService;
    }
    
    function setIssuer(TokenIssuer accessIssuer) returns (bool result){
        issuer=accessIssuer;
        result = true;
    }
    
    function getIssuer() returns (TokenIssuer accessIssuer){
        accessIssuer = issuer;
    }
    
    function setLogger(LogService logService) returns (bool result){
        logger=logService;
        result = true;
    }
    
    function getLogger() returns (LogService logService){
        logService = logger;
    }
    
    function IsAuthorised(address subject, address resource) constant returns (bool result){}

}

contract PolicyDecision is PolicyDecisionBase(){
    
    function PolicyDecision(TokenIssuer accessIssuer, LogService logService) PolicyDecisionBase(accessIssuer,logService){}
    
    function IsAuthorised(address subject, address resource) constant returns (bool result){
        
        //logger = getLogger();
        var (issuedTo, issuedFor, startDate, endDate) = issuer.GetToken(subject,resource);
        if(issuedTo != subject || issuedFor != resource){
            logger.LogAccessDenied("PDP",resource,subject);
            return false;
        }
        if(startDate != 0 && startDate > now){
            logger.LogAccessDenied("PDP",resource,subject);
            return false;
        }
        if(endDate != 0 && endDate < now){
            logger.LogAccessDenied("PDP",resource,subject);
            return false;
        }
        logger.LogAccessGranted("PDP",resource,subject);
        return true;
    }
}


contract LockAPIBase is Disposable{
    
    PolicyDecisionBase policyDecisionPoint;
    
    ////////////////////////////////////////////////////////////////////////////
    // Policy Enforcement Points
    ////////////////////////////////////////////////////////////////////////////
    modifier requireAuthorisation(address subject, address resource){ 
       bool isAuthorised = policyDecisionPoint.IsAuthorised(subject, resource);
       if(!isAuthorised) { return; } _
    }
    
    function LockAPIBase(PolicyDecisionBase pdp){
        policyDecisionPoint = pdp;
    }
    
    function setPolicyDecisionPoint(PolicyDecisionBase pdp) returns (bool result){
        policyDecisionPoint = pdp;  
        result = true;
    }
    
}

contract LockAPI is LockAPIBase(){
    
    struct identityAttributes{
        bytes32 model;
        bytes32 description;
        bool isLocked;
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // Map of Device address to Attributes (1-1)
    ////////////////////////////////////////////////////////////////////////////
    mapping(address=>identityAttributes) public lockAttrs;
    
    ////////////////////////////////////////////////////////////////////////////
    // Map of Device address to Owner Address (1-1)
    ////////////////////////////////////////////////////////////////////////////
    mapping(address=>address) public lockOwner;
    
    ////////////////////////////////////////////////////////////////////////////
    // Map of Owner to Device Address (1-n)
    ////////////////////////////////////////////////////////////////////////////
    mapping(address=>address[]) public ownerLock;
    
    ////////////////////////////////////////////////////////////////////////////
    // Map of Owner to Device Address Count
    ////////////////////////////////////////////////////////////////////////////
    mapping(address=>uint) public ownerLockCount;
    
    function LockAPI(PolicyDecisionBase pdp) LockAPIBase(pdp){}
    
    function Register(address identity, bytes32 model, bytes32 description, bool isLocked) returns(bool result){
        
        identityAttributes memory newIdentity = identityAttributes(model,description,isLocked);
        lockAttrs[identity] = newIdentity;
        lockOwner[identity] = msg.sender;
        ownerLock[msg.sender].push(identity);
        ownerLockCount[msg.sender]++;
        result = true;
    }
    
    function Transfer(address identity, address newOwner) returns (bool result){
        address oldOwner = lockOwner[identity];
        lockOwner[identity] = newOwner;
        ownerLock[newOwner].push(identity);
        
        address[] oldOwnerItems = ownerLock[oldOwner];
        bool done = false;
        
        for(uint i=0; i < oldOwnerItems.length; i++ ){
            if(oldOwnerItems[i] == identity){
                for(uint j = i; j < oldOwnerItems.length-1; j++){
                    if(j+1 <= oldOwnerItems.length-1){
                       oldOwnerItems[j]=oldOwnerItems[j+1];
                    }
                }
                delete oldOwnerItems[oldOwnerItems.length-1];
                done=true;
                break;
            }
            if(done) break;
        }
        
        ownerLockCount[oldOwner]--;
        ownerLockCount[newOwner]++;
        result=true;
    
    }
    
    function Lock(address resource) requireAuthorisation(msg.sender, resource) returns (bool result){
        identityAttributes storage record = lockAttrs[resource];
        record.isLocked=true;
        result=true;
    }
    
    function Unlock(address resource) requireAuthorisation(msg.sender, resource) returns (bool result){
        identityAttributes storage record = lockAttrs[resource];
        record.isLocked=false;
        result = true;
    }
    
}